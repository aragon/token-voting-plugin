TokenVotingTest:
  - given: In the initialize context
    and:
      - when: Calling initialize() on an already initialized plugin
        then:
          - it: reverts if trying to re-initialize
      - when: Calling initialize() on an uninitialized plugin
        then:
          - it: emits the `MembershipContractAnnounced` event
          - it: sets the voting settings, token, minimal approval and metadata
      - given: An IVotes compatible token
        and:
          - when: The token indexes by block number
            then:
              - it: Should use block numbers for indexing
          - when: The token indexes by timestamp
            then:
              - it: Should use timestamps for indexing
          - when: The token does not report any clock data
            then:
              - it: Should assume a block number indexing
      - when: Calling initialize() with a list of excluded accounts
        then:
          - it: Should correctly add all provided addresses to the excludedAccounts set
          - it: Should allow an empty list of excluded accounts
      - when: Calling initialize() with duplicate addresses in the excluded accounts list
        then:
          - it: Should store each address only once in the excludedAccounts set

  - given: In the ERC-165 context
    and:
      - when: Calling supportsInterface('0xffffffff')
        then:
          - it: does not support the empty interface
      - when: Calling supportsInterface for IERC165Upgradeable
        then:
          - it: supports the `IERC165Upgradeable` interface
      - when: Calling supportsInterface for IPlugin
        then:
          - it: supports the `IPlugin` interface
      - when: Calling supportsInterface for IProtocolVersion
        then:
          - it: supports the `IProtocolVersion` interface
      - when: Calling supportsInterface for IProposal
        then:
          - it: supports the `IProposal` interface
      - when: Calling supportsInterface for IMembership
        then:
          - it: supports the `IMembership` interface
      - when: Calling supportsInterface for IMajorityVoting
        then:
          - it: supports the `IMajorityVoting` interface
      - when: Calling supportsInterface for the old IMajorityVoting
        then:
          - it: supports the `IMajorityVoting` OLD interface
      - when: Calling supportsInterface for MajorityVotingBase
        then:
          - it: supports the `MajorityVotingBase` interface
      - when: Calling supportsInterface for the old MajorityVotingBase
        then:
          - it: supports the `MajorityVotingBase` OLD interface
      - when: Calling supportsInterface for TokenVoting
        then:
          - it: supports the `TokenVoting` interface
  - given: In the isMember context
    and:
      - when: An account owns at least one token
        then:
          - it: returns true if the account currently owns at least one token
      - when: An account has at least one token delegated to them
        then:
          - it: returns true if the account currently has at least one token delegated to her/him
  - given: In the IProposal Interface Function context for Proposal creation
    and:
      - when: Creating a proposal with custom encoded data
        then:
          - it: creates proposal with default values if `data` param is encoded with custom values
      - when: Creating a proposal with empty data
        then:
          - it: creates proposal with default values if `data` param is passed as empty

  - given: Account exclusion
    and:
      - when: Calling totalVotingPower() with no accounts in the excluded list
        then:
          - it: Should return the token's past total supply
      - when: Calling totalVotingPower() with one account in the excluded list
        and:
          - given: The excluded account has voting power at the given timepoint
            then:
              - it: Should return the token's past total supply minus the past votes of the excluded accounts
          - when: Creating a proposal
            and:
              - given: The total voting power after excluding accounts is greater than 0
                then:
                  - it: Should create the proposal successfully
                  - it: Should calculate minVotingPower based on the effective total voting power (after exclusions)
                  - it: Should calculate minApprovalPower based on the effective total voting power (after exclusions)
              - given: The total voting power after excluding accounts is 0
                then:
                  - it: Should revert with NoVotingPower()

      - when: Calling totalVotingPower() with multiple accounts in the excluded list
        then:
          - it: Should correctly subtract the past votes of all excluded accounts from the past total supply
      - when: Calling totalVotingPower() with an excluded account that has zero voting power at the timepoint
        then:
          - it: Should produce the same result as if the account was not excluded

  - given: In the Proposal creation context
    and:
      - given: minProposerVotingPower == 0
        and:
          - when: The creator has no voting power
            then:
              - it: creates a proposal if `_msgSender` owns no tokens and has no tokens delegated to her/him in the current block
      - given: minProposerVotingPower > 0
        and:
          - when: The creator has no voting power
            then:
              - it: reverts if `_msgSender` owns no tokens and has no tokens delegated to her/him in the current block
          - when: The creator transfers their voting power away in the same block
            comment: This test uses evm_setAutomine to ensure transactions are in the same block.
            then:
              - it: reverts if `_msgSender` owns no tokens and has no tokens delegated to her/him in the current block although having them in the last block
          - when: The creator owns enough tokens
            then:
              - it: creates a proposal if `_msgSender` owns enough tokens in the current block
          - when: The creator owns enough tokens and has delegated them
            then:
              - it: creates a proposal if `_msgSender` owns enough tokens and has delegated them to someone else in the current block
          - when: The creator has enough delegated tokens
            then:
              - it: creates a proposal if `_msgSender` owns no tokens but has enough tokens delegated to her/him in the current block
          - when: The creator does not have enough tokens (owned or delegated)
            then:
              - it: reverts if `_msgSender` does not own enough tokens herself/himself and has not tokens delegated to her/him in the current block
      - when: The total token supply is 0
        then:
          - it: reverts if the total token supply is 0
      - when: The start date is smaller than the current date
        then:
          - it: reverts if the start date is set smaller than the current date
      - when: The start date would cause an overflow when calculating the end date
        then:
          - it: panics if the start date is after the latest start date
      - when: The end date is before the minimum duration
        then:
          - it: reverts if the end date is before the earliest end date so that min duration cannot be met
      - when: The start and end dates are provided as zero
        then:
          - it: sets the startDate to now and endDate to startDate + minDuration, if zeros are provided as an inputs
      - when: minParticipation calculation results in a remainder
        then:
          - it: ceils the `minVotingPower` value if it has a remainder
      - when: minParticipation calculation does not result in a remainder
        then:
          - it: does not ceil the `minVotingPower` value if it has no remainder
      - when: Creating a proposal with VoteOption.None
        then:
          - it: should create a proposal successfully, but not vote
      - when: Creating a proposal with a vote option (e.g., Yes)
        then:
          - it: should create a vote and cast a vote immediately
      - when: Creating a proposal with a vote option before its start date
        then:
          - it: reverts creation when voting before the start date
  - given: In the Standard Voting Mode
    and:
      - when: Interacting with a non-existent proposal
        then:
          - it: reverts if proposal does not exist
      - when: Voting before the proposal has started
        then:
          - it: does not allow voting, when the vote has not started yet
      - when: A user with 0 tokens tries to vote
        then:
          - it: should not be able to vote if user has 0 token
      - when: Multiple users vote Yes, No, and Abstain
        then:
          - it: increases the yes, no, and abstain count and emits correct events
      - when: A user tries to vote with VoteOption.None
        then:
          - it: reverts on voting None
      - when: A user tries to replace their existing vote
        then:
          - it: reverts on vote replacement
      - when: A proposal meets execution criteria before the end date
        then:
          - it: cannot early execute
      - when: A proposal meets participation and support thresholds after the end date
        then:
          - it: can execute normally if participation and support are met
      - when: Voting with the tryEarlyExecution option
        then:
          - it: does not execute early when voting with the `tryEarlyExecution` option
      - when: Trying to execute a proposal that is not yet decided
        then:
          - it: reverts if vote is not decided yet
      - when: The caller does not have EXECUTE_PROPOSAL_PERMISSION_ID
        then:
          - it: can not execute even if participation and support are met when caller does not have permission
  - given: In the Early Execution Voting Mode
    and:
      - when: Interacting with a non-existent proposal
        then:
          - it: reverts if proposal does not exist
      - when: Voting before the proposal has started
        then:
          - it: does not allow voting, when the vote has not started yet
      - when: A user with 0 tokens tries to vote
        then:
          - it: should not be able to vote if user has 0 token
      - when: Multiple users vote Yes, No, and Abstain
        then:
          - it: increases the yes, no, and abstain count and emits correct events
      - when: A user tries to vote with VoteOption.None
        then:
          - it: reverts on voting None
      - when: A user tries to replace their existing vote
        then:
          - it: reverts on vote replacement
      - when: Participation is large enough to make the outcome unchangeable
        then:
          - it: can execute early if participation is large enough
      - when: Participation and support are met after the voting period ends
        then:
          - it: can execute normally if participation is large enough
      - when: Participation is too low, even if support is met
        then:
          - it: cannot execute normally if participation is too low
      - when: The target operation is a delegatecall
        then:
          - it: executes target with delegate call
      - when: The vote is decided early and the tryEarlyExecution option is used
        then:
          - it: executes the vote immediately when the vote is decided early and the tryEarlyExecution options is selected
      - when: Trying to execute a proposal that is not yet decided
        then:
          - it: reverts if vote is not decided yet
      - when: The caller has no execution permission but tryEarlyExecution is selected
        then:
          - it: record vote correctly without executing even when tryEarlyExecution options is selected
  - given: In the Vote Replacement Voting Mode
    and:
      - when: Interacting with a non-existent proposal
        then:
          - it: reverts if proposal does not exist
      - when: Voting before the proposal has started
        then:
          - it: does not allow voting, when the vote has not started yet
      - when: A user with 0 tokens tries to vote
        then:
          - it: should not be able to vote if user has 0 token
      - when: Multiple users vote Yes, No, and Abstain
        then:
          - it: increases the yes, no, and abstain count and emits correct events
      - when: A user tries to vote with VoteOption.None
        then:
          - it: reverts on voting None
      - when: A voter changes their vote multiple times
        then:
          - it: should allow vote replacement but not double-count votes by the same address
      - when: A proposal meets execution criteria before the end date
        then:
          - it: cannot early execute
      - when: A proposal meets participation and support thresholds after the end date
        then:
          - it: can execute normally if participation and support are met
      - when: Voting with the tryEarlyExecution option
        then:
          - it: does not execute early when voting with the `tryEarlyExecution` option
      - when: Trying to execute a proposal that is not yet decided
        then:
          - it: reverts if vote is not decided yet
  - given: A simple majority vote with >50% support, >=25% participation required and minimal approval >= 21%
    and:
      - when: Support is high but participation is too low
        then:
          - it: does not execute if support is high enough but participation is too low
      - when: Support and participation are high but minimal approval is too low
        then:
          - it: does not execute if support and participation are high enough but minimal approval is too low
      - when: Participation is high but support is too low
        then:
          - it: does not execute if participation is high enough but support is too low
      - when: Participation and minimal approval are high but support is too low
        then:
          - it: does not execute if participation and minimal approval are high enough but support is too low
      - when: All thresholds (participation, support, minimal approval) are met after the duration
        then:
          - it: executes after the duration if participation, support and minimal approval are met
      - when: All thresholds are met and the outcome cannot change
        then:
          - it: executes early if participation, support and minimal approval are met and the vote outcome cannot change anymore
  - given: An edge case with `supportThreshold = 0%`, `minParticipation = 0%`, `minApproval = 0%` in early execution mode
    and:
      - when: There are 0 votes
        then:
          - it: does not execute with 0 votes
      - when: There is at least one 'Yes' vote
        then:
          - it: executes if participation, support and min approval are met
  - given: An edge case with `supportThreshold = 99.9999%`, `minParticipation = 100%` and `minApproval = 100%` in early execution mode
    and:
      - given: Token balances are in the magnitude of 10^18
        and:
          - when: The number of 'Yes' votes is one shy of ensuring the support threshold cannot be defeated
            then:
              - it: early support criterion is sharp by 1 vote
          - when: The number of casted votes is one shy of 100% participation
            then:
              - it: participation criterion is sharp by 1 vote
      - given: Token balances are in the magnitude of 10^6
        and:
          - when: The number of 'Yes' votes is one shy of ensuring the support threshold cannot be defeated
            then:
              - it: early support criterion is sharp by 1 vote
          - when: The number of casted votes is one shy of 100% participation
            then:
              - it: participation is not met with 1 vote missing
  - given: "Execution criteria: multiple orders of magnitude"
    and:
      - when: Testing with a magnitude of 10^0
        then:
          - it: "magnitudes of 10^0"
      - when: Testing with a magnitude of 10^1
        then:
          - it: "magnitudes of 10^1"
      - when: Testing with a magnitude of 10^2
        then:
          - it: "magnitudes of 10^2"
      - when: Testing with a magnitude of 10^3
        then:
          - it: "magnitudes of 10^3"
      - when: Testing with a magnitude of 10^6
        then:
          - it: "magnitudes of 10^6"
      - when: Testing with a magnitude of 10^12
        then:
          - it: "magnitudes of 10^12"
      - when: Testing with a magnitude of 10^18
        then:
          - it: "magnitudes of 10^18"
      - when: Testing with a magnitude of 10^24
        then:
          - it: "magnitudes of 10^24"
      - when: Testing with a magnitude of 10^36
        then:
          - it: "magnitudes of 10^36"
      - when: Testing with a magnitude of 10^48
        then:
          - it: "magnitudes of 10^48"
      - when: Testing with a magnitude of 10^60
        then:
          - it: "magnitudes of 10^60"
      - when: Testing with a magnitude of 10^66
        then:
          - it: "magnitudes of 10^66"
